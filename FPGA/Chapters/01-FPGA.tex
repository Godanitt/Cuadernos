\chapter{Sistemas FPGA}

\section{Concepctos básicos}

En esta sección introduciremos los conceptos básicos en diseño lógico. Presentaremos terminología importante usada en el resto del libro.

\subsection{Álgebra Booleana}

El \textbf{álgebra Booleana} representa las funciones lógicas de los circuitos digitales. Cualquier red de interruptores puede ser modelado por funciones Booleanas. Usamos el álgebra Booleana para describir \textbf{funciones lógicas combinacionales}. Las funciones lógicas básicamente permiten transformar una serie de \textit{inputs} (parámetros de entrada) en una serie de \textit{ouputs} (parámetros de salida). Sean $a$ y $b$ nuestras variables, definimos las siguientes funciones lógicas. Las funciones elementales (NOT, AND y OR) no tienen definición al ser precismante elementales, mientras que las no elementales las podemos definir a partir de las primeras. Sean $a$ y $b$ dos variables cualquiera, escribimos las funciones lógicas en la \cref{Tab:01-Funciones_Logicas}. 

\begin{table}[H] \centering
    \begin{tabular}{cccc} 
        \toprule 
        \textbf{Nombre} & \textbf{Símbolo } & \textbf{Definición} & \textbf{Ejemplo} \\ \midrule
        NOT & ' &  & (1)'=0 \ (0)'=1 \\
        AND  & $\cdot$ &  & 0$\cdot$0=1; 1$\cdot$0=0; 1$\cdot$1=1  \\
        NAND & |  & a | b = (a$\cdot$b)' & 0|0=1; 1|0 = 1; 1|1=0 \\
        OR  & $+$ &  & 0+0=0; 1+0 = 1; 1+1=1 \\
        NOR & NOR &  a NOR b = (a$+$b)' & 0 NOR 0 = 1; 1 NOR 0 = 0; 1 NOR 1 = 0 \\
        XOR & $\oplus$ & a $\oplus$ b = ab'+a'b & 0 $\oplus$ 0 = 0; 1 $\oplus$ 0 = 1; 1 $\oplus$ 1 = 0\\
        XNOR & XNOR & a XNOR b = (a $\oplus$ b)'  & 0 XNOR 0 = 1; 1 XNOR 0 = 0; \\ \bottomrule
    \end{tabular} 
    \caption{}
    \label{Tab:01-Funciones_Logicas}
\end{table}

Lógicamente, como toda álgebra, el álgebra de Boole sigue ciertas reglas de aritmética básicas, tales como: 

\begin{itemize}
    \item \textbf{Ley asociativa:} a + (b+c) = (a+b)+c; a $\cdot$ (b$\cdot$c) = (a $\cdot$ b )$\cdot$c.
    \item \textbf{Ley distributiva:} (a+b)' = a' $\cdot$ b'; (a$\cdot$b)' = a' $+$ b'
\end{itemize}

\subsection{Símobolos lógicos y eléctricos}

Los símbolos eléctricos más usados son: 

\begin{figure}[H] \centering
\begin{circuitikz}
  % NMOS
  \draw (0,0) node[nmos] (N) {};
  \node[below=0.2cm of N] {n-mosfet};

  % PMOS, desplazado
  \draw (3,0) node[pmos] (P) {};
  \node[below=0.2cm of P] {p-mosfet};

  % Dibuja una resistencia con etiquetas
  \draw (4.5,0) to[R, l=$ $] (7,0);
  
  \node (R) at (6,0) {};
  \node[below=0.8cm of R] {Resistencia};

  % Dibuja un capacitor 
  \draw (8,0) to[C, l=$ $] (10,0);
  \node (C) at (9,0) {};
  \node[below=0.8cm of C] {Capacitor};
\end{circuitikz}
\caption{Símbolos para esquemas eléctricos.}
\end{figure}

Mientras que los símbolos en circuitos lógicos son: 

\begin{figure}[H] \centering
\begin{tikzpicture}[scale=10]

  % Inverter
  \node[not gate US, draw, logic gate inputs=nn] (inv) {};
  \node[below=0.2cm of inv] {NOT};

  % NAND
  \node[nand gate US, draw, logic gate inputs=nn, right=1.5cm of inv] (nand) {};
  \node[below=0.2cm of nand] {NAND};

  % NOR
  \node[nor gate US, draw, logic gate inputs=nn, right=1.5cm of nand] (nor) {};
  \node[below=0.2cm of nor] {NOR};

  % AND
  \node[and gate US, draw, logic gate inputs=nn, below=1.5cm of inv, xshift=0.9 cm]  (and) {};
  \node[below=0.2cm of and] {AND};

  % OR
  \node[or gate US, draw, logic gate inputs=nn, right=1.5cm of and] (or) {};m.
  \node[below=0.2cm of or] {OR};

  % XOR
  \node[xor gate US, draw, logic gate inputs=nn, below=1.5cm of and] (xor) {};
  \node[below=0.2cm of xor] {XOR};

  % XNOR
  \node[xnor gate US, draw, logic gate inputs=nn, right=1.5cm of xor] (xnor) {};
  \node[below=0.2cm of xnor] {XNOR};

\end{tikzpicture}
\caption{Símbolos para esquemas lógicos.}
\end{figure}

\section{Diseño digital y FPGAs}

\subsection{El papel de las FPGAs}

Los \textbf{FPGAs} (\textit{Field Programmable Gate Arrays}, en español matriz de puertas lógicas programable en campo) llenan una necesidad existente en el diseño de sistemas digitales, complementario al rol que juegan los microprocesadores. Los microprocesadores pueden ser usados en una cantidad de entornos enorme, pero porque ellos confian en el software para implementar funciones, aunque son generalmente más lentos y consumen más potencia que los chips diseñados con un único propósito (\textit{customizados}). De manera similar, los FPGAS no son chips a medida, por lo que no son tan buenos en funciones particulares. Sin embargo poseen grandes ventajas: 

\begin{itemize}
    \item No tienes porque esperar a acabar el diseño para obtener un chip funcional: el diseño puede ser programado y testeado inmediantemente. 
    \item Son excelentes prototipos. Cuando un FPGA tiene un diseño final, crear un producto o un chip customizado suele ser mucho más fácil.
    \item El mismo FPGA puede ser usado con diferentes diseños. 
\end{itemize}

El área ocupada por las FPGA ha crecido enormemente en los últimos veinte años desde su introducción. Los \textbf{dispositivos de lógica programable PLD} (\textit{Programmable Logic Devices}) estaban en el mercado desde principios de la década de 1970. Estos dispositivos utilizaban estructuras de lógica de dos niveles para implementar la lógica programada. El primer nivel de lógica, el plano AND, generalmente era fijo, mientras que el segundo nivel, conocido como el plano OR, era programable. Los PLD se programaban, en general, mediante antifuses, que se activaban aplicando altos voltajes para establecer las conexiones.

Se utilizaban con mayor frecuencia como \textbf{lógica de enlace } (\textit{glue logic}): lógica necesaria para interconectar los componentes principales del sistema. A menudo se empleaban en prototipos porque podían programarse e insertarse en una placa en cuestión de minutos, pero no siempre llegaban a formar parte del producto final. Los dispositivos de lógica programable no solían considerarse componentes principales de los sistemas en los que se utilizaban. A medida que los sistemas digitales se hicieron más complejos, se necesitaba lógica programable de mayor densidad, y se hicieron evidentes las limitaciones de la lógica de dos niveles de los PLD. La lógica de dos niveles es útil para funciones lógicas relativamente pequeñas, pero con el aumento del nivel de integración, las estructuras de dos niveles se volvieron demasiado ineficientes.

Las FPGA proporcionaron lógica programable usando lógica multinivel de profundidad arbitraria. Utilizaban tanto elementos de lógica programable como interconexiones programables para construir funciones lógicas multinivel. 

A Ross Freeman se le atribuye generalmente la invención de la FPGA. Su FPGA incluía tanto elementos lógicos programables como una estructura de interconexión programable. Su FPGA también se programaba usando memoria SRAM, no antifuses. Esto permitía fabricar la FPGA utilizando procesos estándar de fabricación VLSI, lo que reducía los costos y ofrecía más opciones de manufactura. También permitía que la FPGA se reprogramara mientras estaba en el circuito; esta era una característica particularmente interesante dado que la memoria flash aún no se utilizaba de forma generalizada.

Xilinx y Altera comercializaron las primeras FPGA basadas en SRAM. Una arquitectura alternativa fue introducida por Actel, que empleaba una arquitectura de antifuses. Esta arquitectura no era reprogramable en el campo, lo que se consideraba una ventaja en situaciones que no requerían reconfiguración. Las FPGA de Actel utilizaban una estructura lógica basada en multiplexores organizada en torno a canales de cableado

Durante muchos años las FPGAs han sido vistos como dispositivos de lógica de enlace y como dispositivos para generar prototipos. Hoy en día son usados en todo tipo de sistemas digitales, especialmente en los siguientes campos:
\begin{itemize}
    \item En sistemas de telecomunicaciones extremadamente rápidos.
    \item Como aceleradores de video en grabadoras de video personales.
\end{itemize}

\subsection{Tipos de FPGA}

Pese a qeu hemos hablado de ellos, aún no hemos definido que es un FPGA. Una buena definición podría ser directamente enumerar las características de los PLDs  y los chips customizado, tales como:

\begin{itemize}
    \item Son partes estándar. No estan diseñadas con un propósito particular, pero si son programadas para un propósito particular.
    \item Implementan lógica multi-nivel. Los bloques lógicos dentro de las FPGAs pueden funcioanr como redes de una profundidad arbitaria. Los PLDs por otro lado solo usan dos niveles lógicos: NAND/NOR, lo que limita el tipo de funciones que se pueden implementar eficientemente, pues cualquier función booleana compleja debe transformarse a una forma de solo dos niveles, lo que puede requerir muchas puertas y dificultar el diseño. 
\end{itemize}
Dad que los FPGAs implementan lógica multinivel, son  a la vez bloques lógicos programables y interconexiones programables. 

Para que una FPGA funcione como un circuito digital personalizado, no basta con tener bloques lógicos programables (por ejemplo, LUTs, flip-flops, multiplexores configurables, etc.); también se necesita un sistema que permita conectarlos de cualquier forma necesaria, lo cual se logra con las interconexiones programables.

\begin{itemize}
    \item Los bloques lógicos programables implementan las operaciones lógicas básicas y permiten que el usuario defina qué función booleana realiza cada bloque.

    \item Las interconexiones programables son una red de caminos (switches, multiplexores, etc.) que permiten unir las entradas y salidas de los bloques lógicos según el diseño que el usuario desee. Gracias a ellas, se puede construir cualquier topología de circuito, desde simples puertas combinacionales hasta máquinas de estado complejas.
\end{itemize}
La combinación de bloques lógicos programables y interconexiones programables se llama \textit{fabric} o \textbf{malla} porque posee una estructura regular que puede ser utilizada eficientemente por las herramientas de diseño que asignan la lógica deseada a la FPGA.

Se utilizan diversas tecnologías para programar las FPGA. Algunas FPGA se programan de forma permanente; otras pueden reprogramarse. Las FPGA reprogramables también se conocen como dispositivos reconfigurables. Las FPGA reconfigurables suelen ser preferidas en la construcción de prototipos porque no es necesario desechar el dispositivo cada vez que se realiza un cambio. Los sistemas reconfigurables también pueden reprogramarse dinámicamente durante el funcionamiento del sistema. Esto permite que un mismo hardware desempeñe varias funciones diferentes. Por supuesto, esas funciones no pueden ejecutarse al mismo tiempo, pero la reconfigurabilidad puede ser muy útil cuando un sistema opera en diferentes modos. Por ejemplo, la pantalla del ordenador Radius funcionaba tanto en modo horizontal (paisaje) como en modo vertical (retrato). Cuando el usuario rotaba la pantalla, un interruptor de mercurio provocaba que la FPGA que gestionaba la pantalla se reprogramara para el nuevo modo.

%El FPGA guarda un diseño como un “mapa” de cómo deben estar los switches, y al aplicarlo físicamente, transforma el chip genérico en un circuito específico que implementa tu lógica de manera real y operativa. Un FPGA no es solo una red de switches y LUTs: es un sistema completo de bloques lógicos, memorias, DSPs, interconexiones, interfaces de E/S y circuitería de gestión, todo integrable y configurable para implementar desde una simple puerta lógica hasta sistemas complejos como microcontroladores, procesadores, o procesadores de señal digital.

\section{Lógica Combinacional y secuencial}
Por un lado la \textbf{,ógica combinacional:}
\begin{itemize}
  \item La salida depende únicamente de las entradas actuales.
  \item No existe memoria: el circuito no recuerda estados pasados.
  \item Ejemplos: puertas lógicas, multiplexores, decodificadores, sumadores combinacionales.
\end{itemize}

\[
\text{Salida}(t) = f(\text{Entradas}(t))
\]
por otro lado la \textbf{lógica secuencial:}
\begin{itemize}
  \item La salida depende de las entradas actuales y del estado anterior del sistema.
  \item Utiliza elementos de almacenamiento como flip-flops o latches.
  \item Ejemplos: contadores, registros, máquinas de estados, sistemas de control.
\end{itemize}

\[
\text{Estado}(t+1) = f(\text{Entradas}(t), \text{Estado}(t))
\]
\[
\text{Salida}(t) = g(\text{Entradas}(t), \text{Estado}(t))
\]

La diferncia esencial es entonces que la lógica combinacional no tiene memoria; la lógica secuencial sí, permitiendo que el comportamiento del circuito dependa del tiempo y del historial de entradas.

La \textbf{lógica combinacional} se utiliza para operaciones que requieren procesar las entradas únicamente en el momento actual, sin necesidad de memoria. Es ideal para construir sumadores, restadores, multiplexores, comparadores, decodificadores y en general cualquier circuito que realice una operación aritmética o lógica de manera instantánea. Por ejemplo, se usa para procesar datos en una unidad aritmético-lógica (ALU), decidir rutas en un multiplexor o traducir direcciones en un decodificador. La \textbf{lógica secuencial} se emplea cuando es necesario que el circuito recuerde información, es decir, cuando su comportamiento depende del historial de entradas (los estados anteriores). Se utiliza en contadores para llevar la cuenta de eventos, registros para almacenar datos temporalmente, máquinas de estados para implementar protocolos de comunicación, controladores secuenciales como los de microprocesadores, y pipelines para procesar varias etapas de datos de manera sincronizada. Ejemplos de su uso incluyen cronómetros digitales, controladores de robots, memorias intermedias FIFO y la ejecución paso a paso de instrucciones en un procesador.


